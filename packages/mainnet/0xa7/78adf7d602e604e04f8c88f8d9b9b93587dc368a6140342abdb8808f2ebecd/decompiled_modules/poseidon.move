module 0xa778adf7d602e604e04f8c88f8d9b9b93587dc368a6140342abdb8808f2ebecd::poseidon {
    public entry fun empty() {
    }

    fun add(arg0: u256, arg1: u256) : u256 {
        (arg0 + arg1) % 18446744069414584321
    }

    fun constant_layer(arg0: &vector<u256>, arg1: u64) : vector<u256> {
        let v0 = vector[13080132714287612933, 8594738767457295063, 12896916465481390516, 1109962092811921367, 16216730422861946898, 10137062673499593713, 15292064466732465823, 17255573294985989181, 14827154241873003558, 2846171647972703231, 16246264663680317601, 14214208087951879286, 9667108687426275457, 6470857420712283733, 14103331940138337652, 11854816473550292865, 3498097497301325516, 7947235692523864220, 11110078701231901946, 16384314112672821048, 15404405912655775739, 14077880830714445579, 9555554662709218279, 13859595358210603949, 16859897325061800066, 17685474420222222349, 17858764734618734949, 9410011022665866671, 12495243629579414666, 12416945298171515742, 5776666812364270983, 6314421662864060481, 7402742471423223171, 982536713192432718, 17321168865775127905, 2934354895005980211, 10567510598607410195, 8135543733717919110, 116353493081713692, 8029688163494945618, 9003846637224807585, 7052445132467233849, 9645665432288852853, 5446430061030868787, 16770910634346036823, 17708360571433944729, 4661556288322237631, 11977051899316327985, 4378616569090929672, 3334807502817538491, 8019184735943344966, 2395043908812246395, 6558421058331732611, 11735894060727326369, 8143540538889204488, 5991753489563751169, 12235918791502088007, 2880312033702687139, 18224748115308382355, 18070411013125314165, 8156487614120951180, 10615269510047010719, 12489426404754222075, 5055279340069995710, 7231927319780248664, 2602078848106763799, 12445944369334781425, 3978905923892496205, 16711272944329818038, 10439032361227108922, 15110119871725214866, 821141790655890946, 11073536380651186235, 4866839313097607757, 13118391689513956636, 14527674973762312380, 7612751959265567999, 6808090907814178161, 6899703779492644997, 3664666286336986826, 783179505424462608, 8990689241814097697, 9646603555412825679, 7351246026167205041, 16970959813722173256, 15735726858241466429, 10347018221892268419, 12195545878449322889, 7423314197114049891, 14908016116973904153, 5840340122527363265, 17740311462440614128, 815306421953744623, 17456357368219253949, 6982651076559329072, 11970987324614963868, 8167785008538063246, 9483259819397403968, 954550221664291548, 10339565171024313256, 8651171084286500102, 16974445528003515956, 15104530047940621190, 103271880867179718, 14654666245504492663, 12445769555936887967, 11250582358051997490, 6730977207490590241, 15919951556166196935, 4423540216573360915, 16317664700341473511, 4723997214951767765, 10098756619006575500, 3223149401237667964, 6870494874300767682, 2902095711130291898, 7159372652788439733, 11500508372997952671, 13348148181479462670, 12729401155983882093, 15021242795466053388, 3802990509227527157, 4665459515680145682, 13165553315407675603, 6496364397926233172, 12800832566287577810, 9737592377590267426, 8687131091302514939, 1488200421755445892, 11004377668730991641, 13516338734600228410, 2953581820660217936, 3505040783153922951, 3710332827435113697, 15414874040873320221, 8602547649919482301, 13971349938398812007, 187239246702636066, 12886019973971254144, 4512274763990493707, 2986635507805503192, 2315252455709119454, 12537995864054210246, 2039491936479859267, 1558644089185031256, 4074089203264759305, 2522268501749395707, 3414760436185256196, 17420887529146466921, 2817020417938125001, 16538346563888261485, 5592270336833998770, 16876602064684906232, 1793025614521516343, 2178510518148748532, 2726440714374752509, 6502946837278398021, 15816362857667988792, 12997958454165692924, 5314892854495903792, 15533907063555687782, 12312015675698548715, 14140016464013350248, 16325589062962838690, 6796145646370327654, 1168753512742361735, 4100789820704709368, 15947554381540469177, 8597377839806076919, 9704018824195918000, 12763288618765762688, 17249257732622847695, 1998710993415069759, 923759906393011543, 1271051229666811593, 17822362132088738077, 11797234543722669271, 5864538787265942447, 15975583211110506970, 7258516085733671960, 17999926471875633100, 635992114476018166, 17205047318256576347, 17384900867876315312, 16484825562915784226, 16694130609036138894, 10575069350371260875, 8330575162062887277, 6212375704691932880, 15965138197626618226, 14285453069600046939, 10005163510208402517, 885298637936952595, 541790758138118921, 5985203084790372993, 4685030219775483721, 1411106851304815020, 11290732479954096478, 208280581124868513, 10979018648467968495, 8600643745023338215, 3477453626867126061, 6428436309340258604, 5695415667275657934, 15952065508715623490, 15571300830419767248, 17259785660502616862, 4298425495274316083, 9023601070579319352, 7353589709321807492, 2988848909076209475, 10439527789422046135, 6097734044161429459, 1113429873817861476, 1639063372386966591, 7863102812716788759, 216040220732135364, 14252611488623712688, 9543395466794536974, 2714461051639810934, 2588317208781407279, 15458529123534594916, 15748417817551040856, 16414455697114422951, 13378164466674639511, 13894319928411294675, 5032680892090751540, 17201338494743078916, 4397422800601932505, 11285062031581972327, 7309354640676468207, 10457152817239331848, 8855911538863247046, 4301853449821814398, 13001502396339103326, 10218424535115580246, 8628244713920681895, 17410423622514037261, 14080683768439215375, 11453161143447188100, 16761509772042181939, 6688821660695954082, 12083434295263160416, 8540021431714616589, 6891616215679974226, 10229217098454812721, 3292165387203778711, 6090113424998243490, 13431780521962358660, 6061081364215809883, 16792066504222214142, 16134314044798124799, 17070233710126619765, 6915716851370550800, 9505009849073026581, 6422700465081897153, 17977653991560529185, 5800870252836247255, 12096124733159345520, 7679273623392321940, 17835783910585744964, 2478664878205754377, 1720314468413114967, 10376757819003248056, 10376377187857634245, 13344930747504284997, 11579281865160153596, 10300256980048736962, 378765236515040565, 11412420941557253424, 12931662470734252786, 43018908376346374, 3589810689190160071, 4688229274750659741, 13688957436484306091, 11424740943016984272, 16001900718237913960, 5548469743008097574, 14584404916672178680, 3396622135873576824, 7861729246871155992, 16112271126908045545, 16988163966860016012, 273641680619529493, 15222677154027327363, 4070328078309830604, 13520458500363296391, 8235111705801363015, 5575990058472514138, 2751301609188252989, 6478598528223547074, 386565553848556638, 9417729078939938713, 15204315939835727483, 14942015033780606261, 18369423901636582012, 4715338437538604447, 6840590980607806319, 5535471161490539014, 5341328005359029952, 1475161295215894444, 7999197814297036636, 2984233088665867938, 3097746028144832229, 8849530863480031517, 7464920943249009773, 3802996844641460514, 6284458522545927646, 2307388003445002779, 4461479354745457623, 1649739722664588460, 3008391274160432867, 5142217010456550622, 1775580461722730120, 161694268822794344, 1518963253808031703, 16475258091652710137, 119575899007375159, 1275863735937973999, 16539412514520642374, 2303365191438051950, 6435126839960916075, 17794599201026020053, 13847097589277840330, 16645869274577729720, 8039205965509554440, 4788586935019371140, 15129007200040077746, 2055561615223771341, 4149731103701412892, 10268130195734144189, 13406631635880074708, 11429218277824986203, 15773968030812198565, 16050275277550506872, 11858586752031736643, 8927746344866569756, 11802068403177695792, 157833420806751556, 4698875910749767878, 1616722774788291698, 3990951895163748090, 16758609224720795472, 3045571693290741477, 9281634245289836419, 13517688176723875370, 7961395585333219380, 1606574359105691080, 17564372683613562171, 4664015225343144418, 6133721340680280128, 2667022304383014929, 12316557761857340230, 10375614850625292317, 8141542666379135068, 9185476451083834432, 4991072365274649547, 17398204971778820365, 16127888338958422584, 13586792051317758204];
        let v1 = 12 * arg1;
        let v2 = 0x1::vector::empty<u256>();
        let v3 = &mut v2;
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 0), *0x1::vector::borrow<u256>(&v0, v1)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 1), *0x1::vector::borrow<u256>(&v0, v1 + 1)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 2), *0x1::vector::borrow<u256>(&v0, v1 + 2)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 3), *0x1::vector::borrow<u256>(&v0, v1 + 3)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 4), *0x1::vector::borrow<u256>(&v0, v1 + 4)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 5), *0x1::vector::borrow<u256>(&v0, v1 + 5)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 6), *0x1::vector::borrow<u256>(&v0, v1 + 6)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 7), *0x1::vector::borrow<u256>(&v0, v1 + 7)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 8), *0x1::vector::borrow<u256>(&v0, v1 + 8)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 9), *0x1::vector::borrow<u256>(&v0, v1 + 9)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 10), *0x1::vector::borrow<u256>(&v0, v1 + 10)));
        0x1::vector::push_back<u256>(v3, add(*0x1::vector::borrow<u256>(arg0, 11), *0x1::vector::borrow<u256>(&v0, v1 + 11)));
        v2
    }

    fun full_rounds(arg0: vector<u256>, arg1: u64) : (vector<u256>, u64) {
        let v0 = 0;
        while (v0 < 4) {
            let v1 = &arg0;
            arg0 = constant_layer(v1, arg1);
            let v2 = &arg0;
            arg0 = sbox_layer(v2);
            let v3 = &arg0;
            arg0 = mds_layer(v3);
            arg1 = arg1 + 1;
            v0 = v0 + 1;
        };
        (arg0, arg1)
    }

    public entry fun hash(arg0: vector<u256>, arg1: u64) : vector<u256> {
        hash_n_to_m_no_pad(arg0, arg1)
    }

    fun hash_n_to_m_no_pad(arg0: vector<u256>, arg1: u64) : vector<u256> {
        let v0 = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let v1 = 0x1::vector::length<u256>(&arg0) / 8;
        let v2 = 0;
        while (v2 < v1) {
            let v3 = 0;
            while (v3 < 8) {
                *0x1::vector::borrow_mut<u256>(&mut v0, v3) = *0x1::vector::borrow<u256>(&arg0, v2 * 8 + v3);
                v3 = v3 + 1;
            };
            let v4 = v0;
            v0 = permute(v4);
            v2 = v2 + 1;
        };
        let v5 = 0;
        while (v5 < 0x1::vector::length<u256>(&arg0) % 8) {
            *0x1::vector::borrow_mut<u256>(&mut v0, v5) = *0x1::vector::borrow<u256>(&arg0, v1 * 8 + v5);
            v5 = v5 + 1;
        };
        let v6 = v0;
        v0 = permute(v6);
        let v7 = 0x1::vector::empty<u256>();
        let v8 = 0;
        while (v8 < arg1) {
            0x1::vector::push_back<u256>(&mut v7, *0x1::vector::borrow<u256>(&v0, v8));
            v8 = v8 + 1;
        };
        v7
    }

    fun mds_layer(arg0: &vector<u256>) : vector<u256> {
        let v0 = 0x1::vector::empty<u256>();
        let v1 = &mut v0;
        0x1::vector::push_back<u256>(v1, mds_row_shf(0, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(1, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(2, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(3, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(4, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(5, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(6, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(7, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(8, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(9, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(10, arg0));
        0x1::vector::push_back<u256>(v1, mds_row_shf(11, arg0));
        v0
    }

    public fun mds_row_shf(arg0: u64, arg1: &vector<u256>) : u256 {
        let v0 = 0 + *0x1::vector::borrow<u256>(arg1, arg0) * 17 + *0x1::vector::borrow<u256>(arg1, (arg0 + 1) % 12) * 15 + *0x1::vector::borrow<u256>(arg1, (arg0 + 2) % 12) * 41 + *0x1::vector::borrow<u256>(arg1, (arg0 + 3) % 12) * 16 + *0x1::vector::borrow<u256>(arg1, (arg0 + 4) % 12) * 2 + *0x1::vector::borrow<u256>(arg1, (arg0 + 5) % 12) * 28 + *0x1::vector::borrow<u256>(arg1, (arg0 + 6) % 12) * 13 + *0x1::vector::borrow<u256>(arg1, (arg0 + 7) % 12) * 13 + *0x1::vector::borrow<u256>(arg1, (arg0 + 8) % 12) * 39 + *0x1::vector::borrow<u256>(arg1, (arg0 + 9) % 12) * 18 + *0x1::vector::borrow<u256>(arg1, (arg0 + 10) % 12) * 34 + *0x1::vector::borrow<u256>(arg1, (arg0 + 11) % 12) * 20;
        let v1 = v0;
        if (arg0 == 0) {
            v1 = v0 + *0x1::vector::borrow<u256>(arg1, 0) * 8;
        };
        v1
    }

    fun mod(arg0: u256) : u256 {
        arg0 % 18446744069414584321
    }

    fun partial_rounds(arg0: vector<u256>, arg1: u64) : (vector<u256>, u64) {
        let v0 = 0;
        while (v0 < 22) {
            let v1 = &arg0;
            arg0 = constant_layer(v1, arg1);
            *0x1::vector::borrow_mut<u256>(&mut arg0, 0) = sbox_monomial(*0x1::vector::borrow<u256>(&arg0, 0));
            let v2 = &arg0;
            arg0 = mds_layer(v2);
            arg1 = arg1 + 1;
            v0 = v0 + 1;
        };
        (arg0, arg1)
    }

    fun permute(arg0: vector<u256>) : vector<u256> {
        let (v0, v1) = full_rounds(arg0, 0);
        let (v2, v3) = partial_rounds(v0, v1);
        let (v4, v5) = full_rounds(v2, v3);
        arg0 = v4;
        assert!(v5 == 30, 42);
        let v6 = 0x1::vector::empty<u256>();
        let v7 = &mut v6;
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 0)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 1)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 2)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 3)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 4)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 5)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 6)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 7)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 8)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 9)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 10)));
        0x1::vector::push_back<u256>(v7, mod(*0x1::vector::borrow<u256>(&arg0, 11)));
        v6
    }

    fun sbox_layer(arg0: &vector<u256>) : vector<u256> {
        let v0 = 0x1::vector::empty<u256>();
        let v1 = &mut v0;
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 0)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 1)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 2)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 3)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 4)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 5)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 6)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 7)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 8)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 9)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 10)));
        0x1::vector::push_back<u256>(v1, sbox_monomial(*0x1::vector::borrow<u256>(arg0, 11)));
        v0
    }

    fun sbox_monomial(arg0: u256) : u256 {
        let v0 = mod(arg0 * arg0 * arg0);
        v0 * v0 * arg0
    }

    // decompiled from Move bytecode v6
}

