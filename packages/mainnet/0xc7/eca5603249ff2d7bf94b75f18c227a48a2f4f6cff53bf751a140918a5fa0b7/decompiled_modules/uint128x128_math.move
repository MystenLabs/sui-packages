module 0xc7eca5603249ff2d7bf94b75f18c227a48a2f4f6cff53bf751a140918a5fa0b7::uint128x128_math {
    fun gcd(arg0: u256, arg1: u256) : u256 {
        let v0 = arg0;
        while (arg1 != 0) {
            let v1 = arg1;
            arg1 = arg0 % arg1;
            v0 = v1;
        };
        v0
    }

    public fun log2(arg0: u256) : u256 {
        assert!(arg0 > 0, 300);
        if (arg0 == 0xc7eca5603249ff2d7bf94b75f18c227a48a2f4f6cff53bf751a140918a5fa0b7::constants::scale()) {
            return 0
        };
        let v0 = shr(arg0, 1);
        let (v1, v2) = if (v0 >= 170141183460469231731687303715884105728) {
            (v0, 1)
        } else {
            (28948022309329048855892746252171976963317496166410141009864396001978282409984 / v0, 0)
        };
        let v3 = (0xc7eca5603249ff2d7bf94b75f18c227a48a2f4f6cff53bf751a140918a5fa0b7::bit_math::most_significant_bit(shr(v1, 127)) as u256);
        let v4 = v3 * 170141183460469231731687303715884105728;
        let v5 = shr(v1, v3);
        let v6 = v5;
        if (v5 != 170141183460469231731687303715884105728) {
            let v7 = 170141183460469231731687303715884105728 / 2;
            loop {
                if (v7 == 0) {
                    break
                };
                v6 = shr(v6 * v6, 127);
                if (v6 >= 340282366920938463463374607431768211456) {
                    v4 = v4 + v7;
                    v6 = shr(v6, 1);
                };
                v7 = shr(v7, 1);
            };
        };
        if (v2 == 0) {
            115792089237316195423570985008687907853269984665640564039457584007913129639935 - shl(v4, 1) + 1
        } else {
            shl(v4, 1)
        }
    }

    fun mul_div(arg0: u256, arg1: u256, arg2: u256) : u256 {
        assert!(arg2 > 0, 302);
        if (arg0 == 0 || arg1 == 0) {
            return 0
        };
        if (arg0 == arg2) {
            return arg1
        };
        if (arg1 == arg2) {
            return arg0
        };
        let v0 = gcd(arg0, arg2);
        let v1 = arg0 / v0;
        let v2 = arg2 / v0;
        let v3 = gcd(arg1, v2);
        let v4 = arg1 / v3;
        let v5 = v2 / v3;
        if (v1 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v4) {
            return v1 * v4 / v5
        };
        let v6 = gcd(arg1, arg2);
        let v7 = arg1 / v6;
        let v8 = arg2 / v6;
        let v9 = gcd(arg0, v8);
        let v10 = arg0 / v9;
        if (v10 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v7) {
            return v10 * v7 / v8 / v9
        };
        let v11 = v1 / v5;
        let v12 = v1 % v5;
        let v13 = if (v11 == 0) {
            0
        } else {
            if (v11 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v4) {
                abort 303
            };
            v11 * v4
        };
        let v14 = v13;
        if (v12 > 0) {
            if (v12 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v4) {
                let v15 = v12 * v4 / v5;
                if (v13 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 - v15) {
                    abort 303
                };
                v14 = v13 + v15;
            } else {
                let v16 = gcd(v12, v4);
                let v17 = v12 / v16;
                let v18 = v4 / v16;
                if (v17 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v18) {
                    let v19 = v17 * v18 / v5;
                    if (v13 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 - v19) {
                        abort 303
                    };
                    v14 = v13 + v19;
                } else {
                    let v20 = v4 / v5;
                    let v21 = v4 % v5;
                    if (v20 > 0 && v12 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v20) {
                        let v22 = v12 * v20;
                        if (v13 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 - v22) {
                            abort 303
                        };
                        v14 = v13 + v22;
                    };
                    if (v21 > 0) {
                        let v23 = gcd(v12, v21);
                        let v24 = v12 / v23;
                        let v25 = v21 / v23;
                        if (v24 <= 115792089237316195423570985008687907853269984665640564039457584007913129639935 / v25) {
                            let v26 = v24 * v25 / v5;
                            if (v14 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 - v26) {
                                abort 303
                            };
                            v14 = v14 + v26;
                        };
                    };
                };
            };
        };
        v14
    }

    public fun pow(arg0: u256, arg1: u256) : u256 {
        if (arg1 == 0) {
            return 0xc7eca5603249ff2d7bf94b75f18c227a48a2f4f6cff53bf751a140918a5fa0b7::constants::scale()
        };
        if (arg0 == 0) {
            return 0
        };
        let v0 = 0xc7eca5603249ff2d7bf94b75f18c227a48a2f4f6cff53bf751a140918a5fa0b7::constants::scale();
        let v1 = arg1 > 57896044618658097711785492504343953926634992332820282019728792003956564819967;
        let v2 = if (v1) {
            115792089237316195423570985008687907853269984665640564039457584007913129639935 - arg1 + 1
        } else {
            arg1
        };
        assert!(v2 < 1048576, 301);
        let v3 = pow_recursive(arg0, v2, v0);
        assert!(v3 > 0, 301);
        if (v1) {
            mul_div(v0, v0, v3)
        } else {
            v3
        }
    }

    fun pow_recursive(arg0: u256, arg1: u256, arg2: u256) : u256 {
        if (arg1 == 0) {
            arg2
        } else if (arg1 == 1) {
            arg0
        } else if (arg1 & 1 == 0) {
            pow_recursive(mul_div(arg0, arg0, arg2), arg1 >> 1, arg2)
        } else {
            mul_div(arg0, pow_recursive(arg0, arg1 - 1, arg2), arg2)
        }
    }

    fun shl(arg0: u256, arg1: u256) : u256 {
        if (arg1 == 0) {
            return arg0
        };
        if (arg1 >= 256) {
            return 0
        };
        let v0 = arg0;
        let v1 = arg1;
        if (arg1 >= 128) {
            if (arg0 == 0) {
                return 0
            };
            if (arg0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 340282366920938463463374607431768211456) {
                return 0
            };
            v0 = arg0 * 340282366920938463463374607431768211456;
            v1 = arg1 - 128;
        };
        if (v1 >= 64) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 18446744073709551616) {
                return 0
            };
            v0 = v0 * 18446744073709551616;
            v1 = v1 - 64;
        };
        if (v1 >= 32) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 4294967296) {
                return 0
            };
            v0 = v0 * 4294967296;
            v1 = v1 - 32;
        };
        if (v1 >= 16) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 65536) {
                return 0
            };
            v0 = v0 * 65536;
            v1 = v1 - 16;
        };
        if (v1 >= 8) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 256) {
                return 0
            };
            v0 = v0 * 256;
            v1 = v1 - 8;
        };
        if (v1 >= 4) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 16) {
                return 0
            };
            v0 = v0 * 16;
            v1 = v1 - 4;
        };
        if (v1 >= 2) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 4) {
                return 0
            };
            v0 = v0 * 4;
            v1 = v1 - 2;
        };
        if (v1 >= 1) {
            if (v0 == 0) {
                return 0
            };
            if (v0 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 / 2) {
                return 0
            };
            v0 = v0 * 2;
        };
        v0
    }

    fun shr(arg0: u256, arg1: u256) : u256 {
        if (arg1 == 0) {
            return arg0
        };
        if (arg1 >= 256) {
            return 0
        };
        let v0 = arg0;
        let v1 = arg1;
        if (arg1 >= 128) {
            v0 = arg0 / 340282366920938463463374607431768211456;
            v1 = arg1 - 128;
        };
        if (v1 >= 64) {
            v0 = v0 / 18446744073709551616;
            v1 = v1 - 64;
        };
        if (v1 >= 32) {
            v0 = v0 / 4294967296;
            v1 = v1 - 32;
        };
        if (v1 >= 16) {
            v0 = v0 / 65536;
            v1 = v1 - 16;
        };
        if (v1 >= 8) {
            v0 = v0 / 256;
            v1 = v1 - 8;
        };
        if (v1 >= 4) {
            v0 = v0 / 16;
            v1 = v1 - 4;
        };
        if (v1 >= 2) {
            v0 = v0 / 4;
            v1 = v1 - 2;
        };
        if (v1 >= 1) {
            v0 = v0 / 2;
        };
        v0
    }

    // decompiled from Move bytecode v6
}

