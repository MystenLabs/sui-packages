module 0x833565aa53bdc91d44664ca35c2424a2416b39d61d0597d4ff880d43112aa57f::test_sqrt {
    public fun log2_down(arg0: u256) : u8 {
        let v0 = 0;
        let v1 = v0;
        if (arg0 >> 128 > 0) {
            arg0 = arg0 >> 128;
            v1 = v0 + 128;
        };
        if (arg0 >> 64 > 0) {
            arg0 = arg0 >> 64;
            v1 = v1 + 64;
        };
        if (arg0 >> 32 > 0) {
            arg0 = arg0 >> 32;
            v1 = v1 + 32;
        };
        if (arg0 >> 16 > 0) {
            arg0 = arg0 >> 16;
            v1 = v1 + 16;
        };
        if (arg0 >> 8 > 0) {
            arg0 = arg0 >> 8;
            v1 = v1 + 8;
        };
        if (arg0 >> 4 > 0) {
            arg0 = arg0 >> 4;
            v1 = v1 + 4;
        };
        if (arg0 >> 2 > 0) {
            arg0 = arg0 >> 2;
            v1 = v1 + 2;
        };
        if (arg0 >> 1 > 0) {
            v1 = v1 + 1;
        };
        v1
    }

    public fun min(arg0: u256, arg1: u256) : u256 {
        if (arg0 < arg1) {
            arg0
        } else {
            arg1
        }
    }

    public fun run(arg0: u8) {
        if (arg0 == 0) {
            sqrt_newton(57896044618658097711785492504343953926634992332820282019728792003956564819968);
            sqrt_newton(57896044618658097711785492504343953926634992332820282019728792003956564819968);
            sqrt_newton(26502705971675764943749462511143777737412258453134284371824093019389296640);
            sqrt_newton(411376139330301510538742295639337626245683966408394965837152256);
            sqrt_newton(1461501637330902918203684832716283019655932542976);
            sqrt_newton(76624777043294442917917351357515459180936956109180108800000);
            sqrt_newton(340282366920938463463374607431768211456);
            sqrt_newton(11248566309812931928793734646388138217655420956479549847109632);
            sqrt_newton(102842465557141530964494614962478604644816966013237625450659840);
            sqrt_newton(1329226666556920087987934156473284295655424);
        } else if (arg0 == 1) {
            sqrt_adapted(57896044618658097711785492504343953926634992332820282019728792003956564819968);
            sqrt_adapted(57896044618658097711785492504343953926634992332820282019728792003956564819968);
            sqrt_adapted(26502705971675764943749462511143777737412258453134284371824093019389296640);
            sqrt_adapted(411376139330301510538742295639337626245683966408394965837152256);
            sqrt_adapted(1461501637330902918203684832716283019655932542976);
            sqrt_adapted(76624777043294442917917351357515459180936956109180108800000);
            sqrt_adapted(340282366920938463463374607431768211456);
            sqrt_adapted(11248566309812931928793734646388138217655420956479549847109632);
            sqrt_adapted(102842465557141530964494614962478604644816966013237625450659840);
            sqrt_adapted(1329226666556920087987934156473284295655424);
        } else {
            sqrt_binary_search(57896044618658097711785492504343953926634992332820282019728792003956564819968);
            sqrt_binary_search(57896044618658097711785492504343953926634992332820282019728792003956564819968);
            sqrt_binary_search(26502705971675764943749462511143777737412258453134284371824093019389296640);
            sqrt_binary_search(411376139330301510538742295639337626245683966408394965837152256);
            sqrt_binary_search(1461501637330902918203684832716283019655932542976);
            sqrt_binary_search(76624777043294442917917351357515459180936956109180108800000);
            sqrt_binary_search(340282366920938463463374607431768211456);
            sqrt_binary_search(11248566309812931928793734646388138217655420956479549847109632);
            sqrt_binary_search(102842465557141530964494614962478604644816966013237625450659840);
            sqrt_binary_search(1329226666556920087987934156473284295655424);
        };
    }

    public fun sqrt_adapted(arg0: u256) : u256 {
        if (arg0 == 0) {
            return 0
        };
        let v0 = 1 << ((log2_down(arg0) >> 1) as u8);
        let v1 = v0 + arg0 / v0 >> 1;
        let v2 = v1 + arg0 / v1 >> 1;
        let v3 = v2 + arg0 / v2 >> 1;
        let v4 = v3 + arg0 / v3 >> 1;
        let v5 = v4 + arg0 / v4 >> 1;
        let v6 = v5 + arg0 / v5 >> 1;
        let v7 = v6 + arg0 / v6 >> 1;
        min(v7, arg0 / v7)
    }

    public fun sqrt_binary_search(arg0: u256) : u256 {
        let v0 = 340282366920938463463374607431768211455;
        let v1 = 0;
        let v2 = if (arg0 > v0) {
            v0
        } else {
            arg0
        };
        let v3 = v2;
        let v4 = 0;
        while (v1 <= v3) {
            let v5 = v1 + (v3 - v1) / 2;
            if (v5 * v5 <= arg0) {
                v4 = v5;
                v1 = v5 + 1;
                continue
            };
            v3 = v5 - 1;
        };
        v4
    }

    public fun sqrt_newton(arg0: u256) : u256 {
        let v0 = 1000000000000000000;
        if (arg0 == 0) {
            return 0
        } else {
            let v1 = (arg0 + v0) / 2;
            let v2 = 0;
            while (v2 < 256) {
                if (v1 == arg0) {
                    return arg0
                };
                let v3 = arg0 * v0 / v1 + v1;
                v1 = v3 / 2;
                v2 = v2 + 1;
            };
            abort 0
        };
    }

    // decompiled from Move bytecode v6
}

