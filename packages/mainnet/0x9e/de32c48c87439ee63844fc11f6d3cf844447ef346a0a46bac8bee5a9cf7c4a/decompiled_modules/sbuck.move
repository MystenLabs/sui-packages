module 0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::sbuck {
    struct SBUCK has drop {
        dummy_field: bool,
    }

    struct CollectRewardsCap<phantom T0> has store, key {
        id: 0x2::object::UID,
        flask: 0x2::object::ID,
    }

    struct Flask<phantom T0> has key {
        id: 0x2::object::UID,
        version: u64,
        reserves: 0x2::balance::Balance<T0>,
        sbuck_supply: 0x2::balance::Supply<SBUCK>,
    }

    public fun collect_rewards<T0>(arg0: &mut Flask<T0>, arg1: &CollectRewardsCap<T0>, arg2: 0x2::balance::Balance<T0>) {
        assert_pacakge_version<T0>(arg0);
        assert_flask_id<T0>(arg0, arg1);
        let v0 = 0x2::balance::value<T0>(&arg2);
        assert!(v0 > 0, 101);
        0x2::balance::join<T0>(&mut arg0.reserves, arg2);
        0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::event::collect_rewards(v0);
    }

    public fun deposit<T0>(arg0: &mut Flask<T0>, arg1: 0x2::coin::Coin<T0>) : 0x2::balance::Balance<SBUCK> {
        assert_pacakge_version<T0>(arg0);
        let v0 = 0x2::coin::value<T0>(&arg1);
        assert!(v0 > 0, 101);
        let v1 = if (sbuck_supply<T0>(arg0) == 0) {
            v0
        } else {
            0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::utils::mul_div(v0, sbuck_supply<T0>(arg0), reserves<T0>(arg0))
        };
        assert!(v1 > 0, 102);
        0x2::coin::put<T0>(&mut arg0.reserves, arg1);
        let v2 = 0x2::balance::increase_supply<SBUCK>(&mut arg0.sbuck_supply, v1);
        0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::event::deposit(v0, 0x2::balance::value<SBUCK>(&v2));
        v2
    }

    fun assert_flask_id<T0>(arg0: &Flask<T0>, arg1: &CollectRewardsCap<T0>) {
        assert!(0x2::object::id<Flask<T0>>(arg0) == arg1.flask, 103);
    }

    fun assert_pacakge_version<T0>(arg0: &Flask<T0>) {
        assert!(arg0.version == 1, 1);
    }

    public fun claimable<T0>(arg0: &Flask<T0>, arg1: u64) : u64 {
        if (arg1 > reserves<T0>(arg0)) {
            return 0
        };
        0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::utils::mul_div(arg1, reserves<T0>(arg0), sbuck_supply<T0>(arg0))
    }

    fun init(arg0: SBUCK, arg1: &mut 0x2::tx_context::TxContext) {
        let (v0, v1) = 0x2::coin::create_currency<SBUCK>(arg0, 9, b"sBUCK", b"Savings BUCK", b"yield bearing stablecoin receive the yield generated by Bucket protocol", 0x1::option::some<0x2::url::Url>(0x2::url::new_unsafe_from_bytes(b"https://ipfs.io/ipfs/QmSXhXefmyiwVYLvHNrkXMkY46U1Z7GDGz66Lhoo4Bz3Cx")), arg1);
        0x2::transfer::public_transfer<0x2::coin::TreasuryCap<SBUCK>>(v0, 0x2::tx_context::sender(arg1));
        0x2::transfer::public_freeze_object<0x2::coin::CoinMetadata<SBUCK>>(v1);
    }

    public entry fun initialize<T0>(arg0: 0x2::coin::TreasuryCap<SBUCK>, arg1: &mut 0x2::tx_context::TxContext) {
        let v0 = Flask<T0>{
            id           : 0x2::object::new(arg1),
            version      : 1,
            reserves     : 0x2::balance::zero<T0>(),
            sbuck_supply : 0x2::coin::treasury_into_supply<SBUCK>(arg0),
        };
        let v1 = CollectRewardsCap<T0>{
            id    : 0x2::object::new(arg1),
            flask : 0x2::object::id<Flask<T0>>(&v0),
        };
        0x2::transfer::share_object<Flask<T0>>(v0);
        0x2::transfer::public_transfer<CollectRewardsCap<T0>>(v1, 0x2::tx_context::sender(arg1));
    }

    public fun reserves<T0>(arg0: &Flask<T0>) : u64 {
        0x2::balance::value<T0>(&arg0.reserves)
    }

    public fun reserves_to_supply<T0>(arg0: &Flask<T0>) : u64 {
        reserves<T0>(arg0) / sbuck_supply<T0>(arg0)
    }

    public fun sbuck_supply<T0>(arg0: &Flask<T0>) : u64 {
        0x2::balance::supply_value<SBUCK>(&arg0.sbuck_supply)
    }

    public fun withdraw<T0>(arg0: &mut Flask<T0>, arg1: 0x2::coin::Coin<SBUCK>) : 0x2::balance::Balance<T0> {
        let v0 = 0x2::coin::value<SBUCK>(&arg1);
        assert!(v0 > 0, 101);
        let v1 = 0x2::balance::split<T0>(&mut arg0.reserves, 0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::utils::mul_div(v0, reserves<T0>(arg0), sbuck_supply<T0>(arg0)));
        0x9ede32c48c87439ee63844fc11f6d3cf844447ef346a0a46bac8bee5a9cf7c4a::event::burn(0x2::balance::decrease_supply<SBUCK>(&mut arg0.sbuck_supply, 0x2::coin::into_balance<SBUCK>(arg1)), 0x2::balance::value<T0>(&v1));
        v1
    }

    // decompiled from Move bytecode v6
}

