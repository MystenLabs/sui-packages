module 0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::sbuck {
    struct SBUCK has drop {
        dummy_field: bool,
    }

    struct Flask<phantom T0> has key {
        id: 0x2::object::UID,
        version: u64,
        reserves: 0x2::balance::Balance<T0>,
        sbuck_supply: 0x2::balance::Supply<SBUCK>,
    }

    struct WhitelistCap has store, key {
        id: 0x2::object::UID,
    }

    public fun collect_rewards<T0>(arg0: &mut Flask<T0>, arg1: 0x2::balance::Balance<T0>) {
        assert_package_version<T0>(arg0);
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::event::collect_rewards(0x2::balance::value<T0>(&arg1));
        0x2::balance::join<T0>(&mut arg0.reserves, arg1);
    }

    public fun deposit<T0>(arg0: &mut Flask<T0>, arg1: 0x2::coin::Coin<T0>) : 0x2::balance::Balance<SBUCK> {
        abort 99
    }

    public fun add_protocol<T0, T1: drop>(arg0: &mut Flask<T0>, arg1: &WhitelistCap) {
        0x2::vec_set::insert<0x1::type_name::TypeName>(whitelist_mut<T0>(arg0), 0x1::type_name::get<T1>());
    }

    fun assert_is_whitelisted_protocol<T0, T1: drop>(arg0: &Flask<T0>) {
        let v0 = 0x1::type_name::get<T1>();
        if (!0x2::vec_set::contains<0x1::type_name::TypeName>(whitelist<T0>(arg0), &v0)) {
            err_not_whitelisted_protocol();
        };
    }

    fun assert_package_version<T0>(arg0: &Flask<T0>) {
        if (0x1::u64::diff(package_version(), version<T0>(arg0)) > 1) {
            err_wrong_version();
        };
    }

    fun assert_upgrade_cap(arg0: &0x2::package::UpgradeCap) {
        if (0x2::object::id<0x2::package::UpgradeCap>(arg0) != 0x2::object::id_from_address(@0xc4bdce87ec8084a995511db14fd54ea8591472e760fc334c3662b6a1a0cd7643)) {
            err_invalid_upgrade_cap();
        };
    }

    public fun claim_ratio<T0>(arg0: &Flask<T0>) : 0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::Float {
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::from_fraction(reserves<T0>(arg0), sbuck_supply<T0>(arg0))
    }

    public fun claimable<T0>(arg0: &Flask<T0>, arg1: u64) : u64 {
        if (arg1 > sbuck_supply<T0>(arg0)) {
            err_invalid_share_input();
        };
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::floor(0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::mul(0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::from(arg1), claim_ratio<T0>(arg0)))
    }

    public fun deposit_by_protocol<T0, T1: drop>(arg0: &mut Flask<T0>, arg1: T1, arg2: 0x2::balance::Balance<T0>) : 0x2::balance::Balance<SBUCK> {
        assert_package_version<T0>(arg0);
        assert_is_whitelisted_protocol<T0, T1>(arg0);
        let v0 = 0x2::balance::value<T0>(&arg2);
        let v1 = if (sbuck_supply<T0>(arg0) == 0) {
            v0
        } else {
            sbuck_out_amount<T0>(arg0, v0)
        };
        if (v1 == 0) {
            err_input_too_small();
        };
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::event::deposit(v0, v1);
        0x2::balance::join<T0>(&mut arg0.reserves, arg2);
        0x2::balance::increase_supply<SBUCK>(&mut arg0.sbuck_supply, v1)
    }

    fun err_input_too_small() {
        abort 3
    }

    fun err_invalid_share_input() {
        abort 2
    }

    fun err_invalid_upgrade_cap() {
        abort 1
    }

    fun err_not_whitelisted_protocol() {
        abort 5
    }

    fun err_patch_already_exists() {
        abort 4
    }

    fun err_wrong_version() {
        abort 0
    }

    fun init(arg0: SBUCK, arg1: &mut 0x2::tx_context::TxContext) {
        let (v0, v1) = 0x2::coin::create_currency<SBUCK>(arg0, 9, b"sBUCK", b"Savings BUCK", b"yield bearing stablecoin receive the yield generated by Bucket protocol", 0x1::option::some<0x2::url::Url>(0x2::url::new_unsafe_from_bytes(b"https://ipfs.io/ipfs/QmSXhXefmyiwVYLvHNrkXMkY46U1Z7GDGz66Lhoo4Bz3Cx")), arg1);
        0x2::transfer::public_transfer<0x2::coin::TreasuryCap<SBUCK>>(v0, 0x2::tx_context::sender(arg1));
        0x2::transfer::public_freeze_object<0x2::coin::CoinMetadata<SBUCK>>(v1);
        let v2 = WhitelistCap{id: 0x2::object::new(arg1)};
        0x2::transfer::public_transfer<WhitelistCap>(v2, 0x2::tx_context::sender(arg1));
    }

    public entry fun initialize<T0>(arg0: 0x2::coin::TreasuryCap<SBUCK>, arg1: &mut 0x2::tx_context::TxContext) {
        let v0 = Flask<T0>{
            id           : 0x2::object::new(arg1),
            version      : package_version(),
            reserves     : 0x2::balance::zero<T0>(),
            sbuck_supply : 0x2::coin::treasury_into_supply<SBUCK>(arg0),
        };
        0x2::transfer::share_object<Flask<T0>>(v0);
    }

    public fun package_version() : u64 {
        2
    }

    public fun patch_whitelist<T0, T1: drop>(arg0: &mut Flask<T0>, arg1: &0x2::package::UpgradeCap, arg2: address, arg3: &mut 0x2::tx_context::TxContext) {
        assert_upgrade_cap(arg1);
        let v0 = 0;
        if (0x2::dynamic_field::exists_with_type<u16, 0x2::vec_set::VecSet<0x1::type_name::TypeName>>(&arg0.id, v0)) {
            err_patch_already_exists();
        };
        0x2::dynamic_field::add<u16, 0x2::vec_set::VecSet<0x1::type_name::TypeName>>(&mut arg0.id, v0, 0x2::vec_set::singleton<0x1::type_name::TypeName>(0x1::type_name::get<T1>()));
        let v1 = WhitelistCap{id: 0x2::object::new(arg3)};
        0x2::transfer::transfer<WhitelistCap>(v1, arg2);
    }

    public fun remove_protocol<T0, T1: drop>(arg0: &mut Flask<T0>, arg1: &WhitelistCap) {
        let v0 = 0x1::type_name::get<T1>();
        0x2::vec_set::remove<0x1::type_name::TypeName>(whitelist_mut<T0>(arg0), &v0);
    }

    public fun reserves<T0>(arg0: &Flask<T0>) : u64 {
        0x2::balance::value<T0>(&arg0.reserves)
    }

    public fun reserves_to_supply<T0>(arg0: &Flask<T0>) : u64 {
        claimable<T0>(arg0, 0x1::u64::pow(10, sbuck_decimals()))
    }

    public fun sbuck_decimals() : u8 {
        9
    }

    public fun sbuck_out_amount<T0>(arg0: &Flask<T0>, arg1: u64) : u64 {
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::floor(0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::mul(0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::from(arg1), share_ratio<T0>(arg0)))
    }

    public fun sbuck_supply<T0>(arg0: &Flask<T0>) : u64 {
        0x2::balance::supply_value<SBUCK>(&arg0.sbuck_supply)
    }

    public fun share_ratio<T0>(arg0: &Flask<T0>) : 0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::Float {
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::float::from_fraction(sbuck_supply<T0>(arg0), reserves<T0>(arg0))
    }

    public fun update_version<T0>(arg0: &mut Flask<T0>, arg1: &0x2::package::UpgradeCap, arg2: u64) {
        assert_upgrade_cap(arg1);
        arg0.version = arg2;
    }

    public fun version<T0>(arg0: &Flask<T0>) : u64 {
        arg0.version
    }

    public fun whitelist<T0>(arg0: &Flask<T0>) : &0x2::vec_set::VecSet<0x1::type_name::TypeName> {
        0x2::dynamic_field::borrow<u16, 0x2::vec_set::VecSet<0x1::type_name::TypeName>>(&arg0.id, 0)
    }

    fun whitelist_mut<T0>(arg0: &mut Flask<T0>) : &mut 0x2::vec_set::VecSet<0x1::type_name::TypeName> {
        0x2::dynamic_field::borrow_mut<u16, 0x2::vec_set::VecSet<0x1::type_name::TypeName>>(&mut arg0.id, 0)
    }

    public fun withdraw<T0>(arg0: &mut Flask<T0>, arg1: 0x2::coin::Coin<SBUCK>) : 0x2::balance::Balance<T0> {
        abort 99
    }

    public fun withdraw_by_protocol<T0, T1: drop>(arg0: &mut Flask<T0>, arg1: T1, arg2: 0x2::balance::Balance<SBUCK>) : 0x2::balance::Balance<T0> {
        assert_package_version<T0>(arg0);
        assert_is_whitelisted_protocol<T0, T1>(arg0);
        let v0 = 0x2::balance::value<SBUCK>(&arg2);
        let v1 = claimable<T0>(arg0, v0);
        if (v1 == 0) {
            err_input_too_small();
        };
        0x1798f84ee72176114ddbf5525a6d964c5f8ea1b3738d08d50d0d3de4cf584884::event::burn(v0, v1);
        0x2::balance::decrease_supply<SBUCK>(&mut arg0.sbuck_supply, arg2);
        0x2::balance::split<T0>(&mut arg0.reserves, v1)
    }

    // decompiled from Move bytecode v6
}

