module 0x715b6f9c215d4bad96e71be2f07c7aa699bc720300613f1d882dce6b2a355afb::ifixed {
    public fun abs(arg0: u256) : u256 {
        if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819967) + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
        };
        arg0
    }

    public fun add(arg0: u256, arg1: u256) : u256 {
        let v0 = (arg0 & 57896044618658097711785492504343953926634992332820282019728792003956564819967) + (arg1 & 57896044618658097711785492504343953926634992332820282019728792003956564819967);
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(arg0 ^ v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v0
        };
        v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun close_enough(arg0: u256, arg1: u256, arg2: u256) : bool {
        let v0 = abs(arg0);
        if (less_than(v0, abs(arg1))) {
            return close_enough(arg1, arg0, arg2)
        };
        less_than_eq(from_u256(abs(sub(arg0, arg1))), mul_i256(v0, arg2))
    }

    public fun decimal_scalar_from_decimals(arg0: u64) : u64 {
        assert!(arg0 <= 18, 0);
        let v0 = vector[1000000000000000000, 100000000000000000, 10000000000000000, 1000000000000000, 100000000000000, 10000000000000, 1000000000000, 100000000000, 10000000000, 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1];
        *0x1::vector::borrow<u64>(&v0, arg0)
    }

    public fun diff_sign(arg0: u256, arg1: u256) : bool {
        arg0 ^ arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun div(arg0: u256, arg1: u256) : u256 {
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || arg0 == 0) {
            let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
                (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
            } else {
                arg0
            };
            let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
                (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
            } else {
                arg1
            };
            let v2 = 1000000000000000000 * v0 / v1;
            assert!(v2 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v2
        };
        let v3 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v4 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - (1000000000000000000 * v3 - 1) / v4 + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun div_away_from_zero(arg0: u256, arg1: u256) : u256 {
        if (arg0 == 0) {
            return arg0 / arg1
        };
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        let v2 = (1000000000000000000 * v0 - 1) / v1 + 1;
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v2 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v2
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v2 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun div_toward_zero(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        let v2 = 1000000000000000000 * v0 / v1;
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || arg0 == 0) {
            assert!(v2 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v2
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v2 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun div_up(arg0: u256, arg1: u256) : u256 {
        if (arg0 == 0) {
            return arg0 / arg1
        };
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
                (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
            } else {
                arg0
            };
            let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
                (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
            } else {
                arg1
            };
            let v2 = (1000000000000000000 * v0 - 1) / v1 + 1;
            assert!(v2 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v2
        };
        let v3 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v4 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - 1000000000000000000 * v3 / v4 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun from_balance(arg0: u64, arg1: u256) : u256 {
        let v0 = (arg0 as u256) * arg1;
        assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        v0
    }

    public fun from_u128(arg0: u128) : u256 {
        (arg0 as u256) * 1000000000000000000
    }

    public fun from_u128balance(arg0: u128, arg1: u256) : u256 {
        let v0 = (arg0 as u256) * arg1;
        assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        v0
    }

    public fun from_u128fraction(arg0: u128, arg1: u128) : u256 {
        div(from_u128(arg0), from_u128(arg1))
    }

    public fun from_u256(arg0: u256) : u256 {
        let v0 = arg0 * 1000000000000000000;
        assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        v0
    }

    public fun from_u256balance(arg0: u256, arg1: u256) : u256 {
        let v0 = arg0 * arg1;
        assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        v0
    }

    public fun from_u256fraction(arg0: u256, arg1: u256) : u256 {
        div(from_u256(arg0), from_u256(arg1))
    }

    public fun from_u64(arg0: u64) : u256 {
        (arg0 as u256) * 1000000000000000000
    }

    public fun from_u64fraction(arg0: u64, arg1: u64) : u256 {
        div(from_u64(arg0), from_u64(arg1))
    }

    public fun greater_than(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 > arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun greater_than_eq(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 >= arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun is_cast_safe(arg0: u256) : bool {
        arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun is_neg(arg0: u256) : bool {
        arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun less_than(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 < arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun less_than_eq(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 <= arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun max(arg0: u256, arg1: u256) : u256 {
        if (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 < arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            arg1
        } else {
            arg0
        }
    }

    public fun max_value() : u256 {
        57896044618658097711785492504343953926634992332820282019728792003956564819967
    }

    public fun min(arg0: u256, arg1: u256) : u256 {
        if (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 < arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            arg0
        } else {
            arg1
        }
    }

    public fun min_value() : u256 {
        57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun mul(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return v0 * v1 / 1000000000000000000
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - (v0 * v1 + 999999999999999999) / 1000000000000000000 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun mul_away_from_zero(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return (v0 * v1 + 999999999999999999) / 1000000000000000000
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - (v0 * v1 + 999999999999999999) / 1000000000000000000 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun mul_i256(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        let v2 = v0 * v1;
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v2 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v2
        };
        assert!(v2 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v2 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun mul_toward_zero(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return v0 * v1 / 1000000000000000000
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 * v1 / 1000000000000000000 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun mul_up(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg0
        };
        let v1 = if (arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            (arg1 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        } else {
            arg1
        };
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return (v0 * v1 + 999999999999999999) / 1000000000000000000
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 * v1 / 1000000000000000000 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun neg(arg0: u256) : u256 {
        (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819967) + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun same_sign(arg0: u256, arg1: u256) : bool {
        arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }

    public fun sub(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= arg1) {
            arg0 - arg1
        } else {
            (arg1 - arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        };
        assert!(arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || arg0 ^ v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        v0
    }

    public fun to_balance(arg0: u256, arg1: u256) : u64 {
        assert!(arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        ((arg0 / arg1) as u64)
    }

    public fun to_u128(arg0: u256) : u128 {
        assert!(arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        ((arg0 / 1000000000000000000) as u128)
    }

    public fun to_u128balance(arg0: u256, arg1: u256) : u128 {
        assert!(arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        ((arg0 / arg1) as u128)
    }

    public fun to_u256(arg0: u256) : u256 {
        assert!(arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        arg0 / 1000000000000000000
    }

    public fun to_u256balance(arg0: u256, arg1: u256) : u256 {
        assert!(arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        arg0 / arg1
    }

    public fun to_u64(arg0: u256) : u64 {
        assert!(arg0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        ((arg0 / 1000000000000000000) as u64)
    }

    // decompiled from Move bytecode v6
}

